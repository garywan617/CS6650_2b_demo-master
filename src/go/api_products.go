/*
 * E-commerce API
 *
 * API for managing products, shopping carts, warehouse operations, and credit card processing
 *
 * API version: 1.0.0
 * Contact: support@example.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
)

// 宣告並發安全的 map
var products sync.Map

func init() {
	brands := []string{"Alpha", "Beta", "Gamma", "Delta", "Epsilon"}
	categories := []string{"Electronics", "Books", "Home", "Toys", "Sports"}
	descriptions := []string{
		"High quality product",
		"Best seller item",
		"Limited edition",
		"New arrival",
		"Popular choice",
	}

	// 生成 100,000 products
	for i := 1; i <= 100_000; i++ {
		brand := brands[i%len(brands)]
		category := categories[i%len(categories)]
		description := descriptions[i%len(descriptions)]

		p := Product{
			ProductId:   int32(i),
			ProductName: fmt.Sprintf("Product %s %d", brand, i),
			Category:    category,
			Description: description,
			Brand:       brand,
		}

		products.Store(p.ProductId, p)
	}
}

type ProductsAPI struct {
}

// Post /v1/products/:productId/details
// Add product details
func (api *ProductsAPI) AddProductDetails(c *gin.Context) {
	idStr := c.Param("productId")
	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		c.JSON(400, Error{
			Error:   "INVALID_INPUT",
			Message: "The provided input data is invalid",
			Details: "Product ID must be a positive integer",
		})
		return
	}

	// 檢查 products map 是否初始化
	// if products == nil {
	// 	c.JSON(http.StatusInternalServerError, Error{
	// 		Error:   "INTERNAL_SERVER_ERROR",
	// 		Message: "Something went wrong on the server",
	// 		Details: "Products map is not initialized",
	// 	})
	// 	return
	// }

	var newProduct Product

	// Call BindJSON to bind the received JSON to
	// newProduct.
	if err := c.BindJSON(&newProduct); err != nil {
		c.JSON(400, Error{
			Error:   "INVALID_INPUT",
			Message: "Invalid JSON body",
			Details: err.Error(),
		})
		return
	}

	// 檢查 productId 是否對應
	if newProduct.ProductId != int32(id) {
		c.JSON(400, Error{
			Error:   "INVALID_INPUT",
			Message: "Product ID mismatch",
			Details: "ProductId in body must match URL path",
		})
		return
	}

	// 存到 map
	// products[newProduct.ProductId] = newProduct
	// 存到 sync.map
	products.Store(newProduct.ProductId, newProduct)
	c.IndentedJSON(204, newProduct)
}

// Get /v1/products/:productId
// Get product by ID
func (api *ProductsAPI) GetProduct(c *gin.Context) {
	// Your handler implementation
	idStr := c.Param("productId")
	id, err := strconv.Atoi(idStr)
	if err != nil || id <= 0 {
		apiError := Error{
			Error:   "INVALID_INPUT",
			Message: "The provided input data is invalid",
			Details: "Product ID must be a positive integer",
		}
		c.IndentedJSON(400, apiError)
		return
	}
	// 檢查 products map 是否初始化
	// if products == nil {
	// 	apiError := Error{
	// 		Error:   "INTERNAL_SERVER_ERROR",
	// 		Message: "Something went wrong on the server",
	// 		Details: "Products map is not initialized",
	// 	}
	// 	c.IndentedJSON(http.StatusInternalServerError, apiError)
	// 	return
	// }

	//product, exists := products[int32(id)]
	product, exists := products.Load(int32(id))
	if !exists {
		apiError := Error{
			Error:   "Product not found",
			Message: "The provided product ID is not found",
			Details: "Product ID does not exist in the system",
		}
		c.IndentedJSON(404, apiError)
		return
	}

	c.IndentedJSON(200, product)
}

func (api *ProductsAPI) SearchProducts(c *gin.Context) {
	query := strings.ToLower(c.Query("q"))
	if query == "" {
		c.JSON(400, gin.H{"error": "query parameter 'q' is required"})
		return
	}

	maxCheck := 100
	maxResults := 20
	totalFound := 0
	results := make([]Product, 0, maxResults)
	count := 0

	// 記錄開始時間
	start := time.Now()

	products.Range(func(key, value any) bool {
		if count >= maxCheck {
			return false // 停止迭代
		}
		count++

		p := value.(Product)
		if strings.Contains(strings.ToLower(p.ProductName), query) ||
			strings.Contains(strings.ToLower(p.Category), query) {
			totalFound++
			if len(results) < maxResults {
				results = append(results, p)
			}
		}

		return true // 繼續迭代
	})
	// 計算搜尋耗時
	elapsed := time.Since(start).Seconds()

	c.JSON(200, gin.H{
		"products":    results,
		"total_found": totalFound,
		"search_time": fmt.Sprintf("%.6fs", elapsed),
	})
}
